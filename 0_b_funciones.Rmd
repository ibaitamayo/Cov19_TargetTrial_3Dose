---
title: "Funciones"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---


```{r librerias, echo=FALSE, message=FALSE, include=FALSE, warning=FALSE}
source("0_a_librerias.R")

# creo una función ficticia para ver si se han cargado las funciones
se_ha_cargado_f <- "Sí"

```

# Descripción

***

En este .Rmd van a estar todas las funciones que se utilizarán para la creación del target trial, así como otras funciones auxiliares que se van a utilizar para el limpiado de la base y la creación de los resultados. El objetivo último, es acabar convirtiendo este .Rmd en un paquete de R. Como manera de estructurar el trabajo, cada función irá por separado en un chunk.

# Funciones auxiliares

***

En esta sección se encuentran las funciones auxiliares.

## fymd

Función que transforma los 10 primeros carácteres de una cadena en una fecha mediante la función de ymd de la librería lubridate.

```{r fymd}
# fecha en texto a ymd
fymd <- function(x) {
  x = as.Date(ymd(str_sub(x, 1, 10)))
  }

```

## fnullna

Función que transforma una cadena con texto "NULL" a NA.

```{r fnullna}

fnullna <- function(x) {
  x = if_else(x == "NULL", NA_character_, x)
  }

```

## fnull0

Función que transforma una cadena con texto "NULL" a "0".

```{r fnull0}

fnull0 <- function(x) {
  x = if_else(x == "NULL", 0, as.numeric(x))
  }

```


# Funciones del Target Trial

***

## excluir

Función que realiza un criterio de exclusión a partir de una variable de un tibble.

```{r}
# función para excluir siguiendo un criterio-----------------------------------
excluir <- function(pob, 
                    crit,
                    var)
{
  
  if (is.logical(pob %>% pull(var)) == TRUE) {
  print(glue("Variable lógica. {crit}"))
  pob <- pob %>% filter(is.na(get(var)) |
                     get(var) != TRUE)
    print(glue("n : {nrow(pob)}"))
  pob
  }
  else {
  print(glue("Variable no lógica. {crit}"))
  pob <- pob %>% filter(!is.na(get(var)))
    print(glue("n : {nrow(pob)}"))
  pob
  }
}

```

## hacer_flujo

Está función aplica los **criterios de exclusión que no dependen del tiempo**, uno detrás de otro, informando del flow.

```{r}
# flujo------------------------------------------------------------------------
hacer_flujo <- function(data,
                        exc = lista_exclusion
                   ) 
  {
  print(glue("n de partida: {nrow(data)}"))

  for( i in seq_along(exc$criterios)) {
  data <- excluir(pob = data,
                  crit = exc$criterios[[i]],
                  var = exc$variables[[i]])
}
  data
  }
  
```

## excluir_dep

Función que realiza un criterio de exclusión a partir de una variable de un tibble que es dependiente del tiempo_0 elegido.

```{r}
# función para excluir siguiendo un criterio-----------------------------------
excluir_dep <- function(pob, 
                        crit,
                        var,
                        t_var,
                        t0,
                        vb)
{
  if (t_var == "exc"){
    if (vb == TRUE) print(glue("Variable exclusión. {crit}"))
  pob <- pob %>% filter(is.na(get(var)) | get(var) >= t0)
    if (vb == TRUE) print(glue("n : {nrow(pob)}"))
  pob
  }
  else {
    if (vb == TRUE) print(glue("Variable inclusión. {crit}"))
  pob <- pob %>% filter(get(var) <= t0)
    if (vb == TRUE) print(glue("n : {nrow(pob)}"))
  pob
  }
}

```

## hacer_flujo_dep

Está función aplica los **criterios de exclusión que sí dependen del tiempo**, uno detrás de otro, informando del flow.

```{r}
# flujo------------------------------------------------------------------------
hacer_flujo_dep <- function(data,
                            exc = lista_exclusion_dep,
                            tiempo_0 = tiempo_0,
                            verbose = TRUE
                   ) 
  {
  tiempo_0 <- ymd(tiempo_0)
  print(glue("n de partida: {nrow(data)}"))
  for(i in seq_along(exc$criterios)) {
  data <- excluir_dep(
                       pob = data,
                       crit = exc$criterios[[i]],
                       var = exc$variables[[i]],
                       t_var = exc$tipo_var[[i]],
                       t0 = tiempo_0,
                       vb = verbose)
}
  data
  }

```

## f_matching_tt

Función que, para una fecha determinada (tiempo_0) realiza:

- Los criterios de exclusión dependientes del tiempo.
- Define la exposición en la población.
- Realiza matching (1:1) de esa población.

Además, permite definir cuál va a ser la variable de censura, cuál es el tiempo de seguimiento y si va a haber alguna variable de matching que sea dependiente del tiempo. 

Asimismo, permite introducir una base de test previos, para crear una variable de test negativos previos en el tiempo_0, que será introducida como una variable de matching.

Por último, se permite definir la cantidad de información que queremos que aparezca por pantalla (*verbose*) y el valor de la semilla (*seed*) para obtener siempre el mismo resultado en el matching.

```{r}
# función de matching----------------------------------------------------------
f_matching_tt <- function(data, 
                             tiempo_0, 
                             crit_exc,
                             exposure,
                             out,
                             censoring = "fdef",
                             vector_match,
                             follow_up = 60,
                             temporal_var = NULL,
                             temporal_var_unit,
                             base_test = NULL,
                             verbose = TRUE,
                             seed = 1) {
  
  set.seed(seed)
  tiempo_0 <- ymd(tiempo_0)
  print(glue("tiempo_0 = {tiempo_0}"))
  if (verbose == TRUE) print(glue("Outcome = {out}"))
  if (verbose == TRUE) print(glue("n de partida: {nrow(data)}"))
  
  # exclusiones dependientes del tiempo
  for(i in seq_along(crit_exc$criterios)) {
  data <- excluir_dep(
                       pob = data,
                       crit = crit_exc$criterios[[i]],
                       var = crit_exc$variables[[i]],
                       t_var = crit_exc$tipo_var[[i]],
                       t0 = tiempo_0,
                       vb = verbose)
  }
  
  # exclusión por el outcome
    if (verbose == TRUE) print(glue("Variable exclusión. {out}"))
    if (out %in% crit_exc$variables) {
    if (verbose == TRUE) print("Criterio de exclusión ya aplicado")
    } else {
     data <- data %>% filter(is.na(get(out)) | get(out) >= tiempo_0)
    if (verbose == TRUE) print(glue("n : {nrow(pob)}"))
    }
  
  # obtención número de test negativos previos al primer positivo
  if (!is.null(base_test)) {
  data <- base_test %>% filter(id %in% data$id,
                               tpos == FALSE,
                               ftes < tiempo_0) %>% 
    group_by(id) %>% 
    summarise(n_0 = max(n)) %>% 
    right_join(data, by = "id") %>% 
    mutate(n_0 = case_when(is.na(n_0) ~ 0L, 
                 n_0 > 3 ~ 3L,
                 T ~ n_0)) 
  vector_match <- c(vector_match, "n_0")
  }
  
  # creación de variable temporal respecto a tiempo_0
  if (!is.null(temporal_var)) {
  data <- data %>% 
  mutate(temp_var = as.numeric(tiempo_0 - 
                    floor_date(get(temporal_var), unit = temporal_var_unit)))
  vector_match <- c(vector_match, "temp_var")
  }
  
  # exposicion-seguimiento
  data <- data %>% 
    mutate( exposicion = if_else(tiempo_0 == get(exposure) & 
                                     !is.na(get(exposure)), 1, 0),
              date_start = tiempo_0,
              date_end = tiempo_0 %m+% days(follow_up),
              date_end = if_else(!is.na(get(censoring)) & 
                          get(censoring) < date_end, get(censoring), date_end),
              date_end = if_else(exposicion == 0 & !is.na(get(exposure)) & 
                         get(exposure) < date_end,  get(exposure), date_end))
  
  # meter variables del matching como numéricas  
  suppressWarnings(data <- data %>%
    mutate(across(.cols = all_of(vector_match), 
                  .fns = ~if_else(is.na(as.numeric(.x)) == TRUE, 
                                  as.numeric(as.factor(.x)),
                                  as.numeric(.x)))))      
  # hacer matching (investigar distintas opciones)
  try({
    greedymatch <- Matching::Match(Tr = data$exposicion, M = 1, 
                   X = data[vector_match], exact = TRUE, ties = FALSE)
    a <- data[unlist(greedymatch[c("index.treated", "index.control")]),]
    par <- rep(1:(nrow(a)/2), 2)
    bind_cols(par = par, a) %>%
      group_by(par) %>%
      mutate(date_end = min(date_end),
        # creo la variable de resultado y finalizo el seguimiento cuando aparece)
         caso = if_else(get(out) <= date_end & !is.na(get(out)), 1, 0),
         date_end = if_else(caso == 1, get(out), date_end)) %>% 
      as_tibble() 
    }
  )
}

```

## f_matching_tt_mult 

Extensión de la función f_matching_tt, en la cuál se obtiene un ensayo clínico emulado para cada tiempo_0 y se unen en un único *tibble*.

```{r}
# función de matching para múltiples fechas------------------------------------
f_matching_tt_mult <- function(data, 
                             f_ini,
                             f_fin,
                             crit_exc,
                             exposure,
                             out,
                             censoring = "fdef",
                             vector_match,
                             follow_up = 60,
                             temporal_var = NULL,
                             temporal_var_unit,
                             base_test = NULL,
                             verbose = TRUE,
                             seed = 1){
  
  fechas <- seq.Date(from = ymd(f_ini), to = ymd(f_fin), by = "days")
  
  tt_tibble =  map(fechas, 
      f_matching_tt,
      data = data,
      crit_exc = crit_exc,
      vector_match = vector_match, 
      exposure = exposure,
      out = out, 
      follow_up = follow_up,
      base_test = base_test,
      temporal_var = temporal_var,
      temporal_var_unit = temporal_var_unit,
      verbose = FALSE,
      seed = seed) %>% 
    # descartar los días en los que no se encuentra matching
    keep(~is_tibble(.x)) %>%  
    # unir todos los tibbles de la lista en uno único
    enframe() %>%
    rename(target_trial_number = name) %>% 
    unnest(value) %>% 
    # para evitar errores en el matcheo
    filter(!is.na(exposicion))

  if (!is.null(temporal_var)) {
  vector_match  <- c(vector_match, 
                     glue("{temporal_var} (in {temporal_var_unit})"))
  }  

  if (!is.null(base_test)) {
  vector_match <- c(vector_match, "n_0")
  }  

  return(lst(tt_tibble = tt_tibble,
       out = out,
       vector_match = vector_match))  
}


```

## f_analisis

En esta función se analizan los resultados obtenidos en la función *f_matching_tt_mult*. En la lista que se genera en la función anterior, se incluye el *outcome* y *las variables de matching*, las cuales se muestran por pantalla en la función de análisis. Además, se puede introducir el tiempo necesario para que la exposición surta efecto (*tiempo_efecto*). En el caso de que haya un *tiempo_efecto*, se muestra un aumento de la figura de Kaplan-Meier para ese intervalo de tiempo, en el que idealmente, las curvas se deberían superponer. Asimismo, se puede configurar el límite inferior del eje y (*lim_1* y *lim_zoom*) de la gráfica de Kaplan-Meier.

```{r}
# función que realiza el análisis de supervivencia-----------------------------
f_analisis <- function(
                lista,
                tiempo_efecto = 0,
                lim_1 = 0.8,
                lim_zoom = 0.95
                       ) {
  
  base_analisis <- lista$tt_tibble %>% 
    mutate(survtime = date_end - date_start)
  
  print(glue("Se está analizando el outcome: {lista$out} \\
             mediante la emulación de un ensayo clínico  \\
             con múltiples inicios de tiempo. Se ha utilizado matching por: \\
             {str_c(lista$vector_match, collapse = ', ')}.
             
             "))
             
  print(base_analisis %>% 
             tabyl(exposicion, caso) %>%
             adorn_totals(where = c('row', 'col')) %>%
             adorn_title())

  fit <- survfit(Surv(survtime, caso) ~ exposicion, data = base_analisis) 

  print(ggsurvplot(fit, data = base_analisis, xlab = "days of follow-up",
           ylab = "Survival probability",
           main = "Product-Limit Survival Estimates", 
           ylim = c(lim_1, 1), 
           risk.table = TRUE, conf.int = TRUE))
  
  if (tiempo_efecto != 0) {
  print(ggsurvplot(fit, data = base_analisis, 
           xlab = "days of follow-up",
           ylab = "Survival probability",
           main = "Product-Limit Survival Estimates: Zoom at tiempo-efecto", 
           xlim = c(0, tiempo_efecto),
           ylim = c(lim_zoom, 1), 
           risk.table = TRUE, conf.int = TRUE))
  }
  
  # El tiempo_efecto se introduce como un argumento
  cpp = coxph(formula = Surv(survtime, caso) ~ exposicion, 
              subset = survtime > tiempo_efecto,
              data = base_analisis)
  
  # imprimir resultado
  print(glue("
  
             # Estimated effectiveness in Navarra for {out} is : \\
             {round((1 - exp(coef(cpp))) * 100, 1)} % \\
             ({round((1 - exp(confint(cpp))[2]) * 100, 1)} - \\
             {round((1 - exp(confint((cpp)))[1]) * 100, 1)} %)"))
}

```
