---
title: "Funciones"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---


```{r librerias, echo=FALSE, message=FALSE, include=FALSE, warning=FALSE}
source("0_a_librerias.R")

# creo una función ficticia para ver si se han cargado las funciones
se_ha_cargado_f <- "Sí"

```

# Descripción

***

En este .Rmd van a estar todas las funciones que se utilizarán para la creación del target trial, así como otras funciones auxiliares que se van a utilizar para el limpiado de la base y la creación de los resultados. El objetivo último, es acabar convirtiendo este .Rmd en un paquete de R. Como manera de estructurar el trabajo, cada función irá por separado en un chunk.

# Funciones auxiliares

***

En esta sección se encuentran las funciones auxiliares.

## fymd

Función que transforma los 10 primeros carácteres de una cadena en una fecha mediante la función de ymd de la librería lubridate.

```{r fymd}
# fecha en texto a ymd
fymd <- function(x) {
  x = as.Date(ymd(str_sub(x, 1, 10)))
  }

```

## fnullna

Función que transforma una cadena con texto "NULL" a NA.

```{r fnullna}

fnullna <- function(x) {
  x = if_else(x == "NULL", NA_character_, x)
  }

```

## fnull0

Función que transforma una cadena con texto "NULL" a "0".

```{r fnull0}

fnull0 <- function(x) {
  x = if_else(x == "NULL", 0, as.numeric(x))
  }

```


# Funciones del Target Trial

***

## excluir

Función que realiza un criterio de exclusión a partir de una variable de un tibble.

```{r}
# función para excluir siguiendo un criterio-----------------------------------
excluir <- function(pob, 
                    crit,
                    var)
{
  
  if (is.logical(pob %>% pull(var)) == TRUE) {
  print(glue("Variable lógica. {crit}"))
  pob <- pob %>% filter(is.na(get(var)) |
                     get(var) != TRUE)
    print(glue("n : {nrow(pob)}"))
  pob
  }
  else {
  print(glue("Variable no lógica. {crit}"))
  pob <- pob %>% filter(!is.na(get(var)))
    print(glue("n : {nrow(pob)}"))
  pob
  }
}

```

## hacer_flujo

Está función aplica los **criterios de exclusión que no dependen del tiempo**, uno detrás de otro, informando del flow.

```{r}
# flujo------------------------------------------------------------------------
hacer_flujo <- function(data,
                        exc = lista_exclusion
                   ) 
  {
  print(glue("n de partida: {nrow(data)}"))

  for( i in seq_along(exc$criterios)) {
  data <- excluir(pob = data,
                  crit = exc$criterios[[i]],
                  var = exc$variables[[i]])
}
  data
  }
  
```

## excluir_dep

Función que realiza un criterio de exclusión a partir de una variable de un tibble que es dependiente del tiempo_0 elegido.

```{r}
# función para excluir siguiendo un criterio-----------------------------------
excluir_dep <- function(pob, 
                        crit,
                        var,
                        t_var,
                        t0,
                        vb)
{
  if (t_var == "exc"){
    if (vb == TRUE) print(glue("Variable exclusión. {crit}"))
  pob <- pob %>% filter(is.na(get(var)) | get(var) >= t0)
    if (vb == TRUE) print(glue("n : {nrow(pob)}"))
  pob
  }
  else {
    if (vb == TRUE) print(glue("Variable inclusión. {crit}"))
  pob <- pob %>% filter(get(var) <= t0)
    if (vb == TRUE) print(glue("n : {nrow(pob)}"))
  pob
  }
}

```

## hacer_flujo_dep

Está función aplica los **criterios de exclusión que sí dependen del tiempo**, uno detrás de otro, informando del flow.

```{r}
# flujo------------------------------------------------------------------------
hacer_flujo_dep <- function(data,
                            exc = lista_exclusion_dep,
                            tiempo_0 = tiempo_0,
                            verbose = TRUE
                   ) 
  {
  tiempo_0 <- ymd(tiempo_0)
  print(glue("n de partida: {nrow(data)}"))
  for(i in seq_along(exc$criterios)) {
  data <- excluir_dep(
                       pob = data,
                       crit = exc$criterios[[i]],
                       var = exc$variables[[i]],
                       t_var = exc$tipo_var[[i]],
                       t0 = tiempo_0,
                       vb = verbose)
}
  data
  }

```

# f_matching_tt

***

Función que, para una fecha determinada (tiempo_0) realiza:

- Los criterios de exclusión dependientes del tiempo.
- Define la exposición en la población.
- Realiza matching (1:1) de esa población.

Además, permite definir cuál va a ser la variable de censura, cuál es el tiempo de seguimiento y si va a haber alguna variable de matching que sea dependiente del tiempo. 

Asimismo, permite introducir una base de test previos, para crear una variable de test negativos previos en el tiempo_0, que será introducida como una variable de matching.

Por último, se permite definir la cantidad de información que queremos que aparezca por pantalla (*verbose*) y el valor de la semilla (*seed*) para obtener siempre el mismo resultado en el matching.

```{r}
# función de matching----------------------------------------------------------
f_matching_tt <- function(data, 
                             tiempo_0, 
                             crit_exc,
                             exposure,
                             out,
                             censoring = "fdef",
                             vector_match,
                             follow_up = 60,
                             temporal_var = NULL,
                             base_test = NULL,
                             verbose = TRUE,
                             seed = 1) {
  
  set.seed(seed)
  tiempo_0 <- ymd(tiempo_0)
  print(glue("tiempo_0 = {tiempo_0}"))
  if (verbose == TRUE) print(glue("Outcome = {out}"))
  if (verbose == TRUE) print(glue("n de partida: {nrow(data)}"))
  
  # exclusiones dependientes del tiempo
  for(i in seq_along(crit_exc$criterios)) {
  data <- excluir_dep(
                       pob = data,
                       crit = crit_exc$criterios[[i]],
                       var = crit_exc$variables[[i]],
                       t_var = crit_exc$tipo_var[[i]],
                       t0 = tiempo_0,
                       vb = verbose)
  }
  
  # exclusión por el outcome
    if (verbose == TRUE) print(glue("Variable exclusión. {out}"))
    if (out %in% crit_exc$variables) {
    if (verbose == TRUE) print("Criterio de exclusión ya aplicado")
    } else {
     data <- data %>% filter(is.na(get(out)) | get(out) >= tiempo_0)
    if (verbose == TRUE) print(glue("n : {nrow(pob)}"))
    }
  
  # obtención número de test negativos previos al primer positivo
  if (!is.null(base_test)) {
  data <- base_test %>% filter(id %in% data$id,
                               tpos == FALSE,
                               ftes < tiempo_0) %>% 
    group_by(id) %>% 
    summarise(n_0 = max(n)) %>% 
    right_join(data, by = "id") %>% 
    mutate(n_0 = case_when(is.na(n_0) ~ 0L, 
                 n_0 > 3 ~ 3L,
                 T ~ n_0)) 
  vector_match <- c(vector_match, "n_0")
  }
  
  # creación de variable temporal respecto a tiempo_0
  if (!is.null(temporal_var)) {
  data <- data %>% 
  mutate(temp_var = as.numeric(tiempo_0 - get(temporal_var)))
  vector_match <- c(vector_match, "temp_var")
  }
  
  # exposicion-seguimiento
  data <- data %>% 
    mutate( exposicion = if_else(tiempo_0 == get(exposure) & 
                                     !is.na(get(exposure)), 1, 0),
              date_start = tiempo_0,
              date_end = tiempo_0 %m+% days(follow_up),
              date_end = if_else(!is.na(get(censoring)) & 
                          get(censoring) < date_end, get(censoring), date_end),
              date_end = if_else(exposicion == 0 & !is.na(get(exposure)) & 
                         get(exposure) < date_end,  get(exposure), date_end))
  
  # meter variables del matching como numéricas  
  suppressWarnings(data <- data %>%
    mutate(across(.cols = all_of(vector_match), 
                  .fns = ~if_else(is.na(as.numeric(.x)) == TRUE, 
                                  as.numeric(as.factor(.x)),
                                  as.numeric(.x)))))      
  # hacer matching (investigar distintas opciones)
  try({
    greedymatch <- Matching::Match(Tr = data$exposicion, M = 1, 
                   X = data[vector_match], exact = TRUE, ties = FALSE)
    a <- data[unlist(greedymatch[c("index.treated", "index.control")]),]
    par <- rep(1:(nrow(a)/2), 2)
    bind_cols(par = par, a) %>%
      group_by(par) %>%
      mutate(date_end = min(date_end),
        # creo la variable de resultado y finalizo el seguimiento cuando aparece)
         caso = if_else(get(out) <= date_end & !is.na(get(out)), 1, 0),
         date_end = if_else(caso == 1, get(out), date_end)) %>% 
      as_tibble() 
    }
  )
}

```

## f_matching_tt_mult 

Extensión de la función f_matching_tt, en la cuál se obtiene un ensayo clínico emulado para cada tiempo_0 y se unen en un único *tibble*.

```{r}
# función de matching para múltiples fechas------------------------------------
f_matching_tt_mult <- function(data, 
                             tiempo_0, 
                             crit_exc,
                             exposure,
                             out,
                             censoring = "fdef",
                             vector_match,
                             follow_up = 60,
                             temporal_var = NULL,
                             base_test = NULL,
                             verbose = TRUE,
                             seed = 1) {
  
  map(tiempo_0, 
      f_matching_tt,
      data = data,
      crit_exc = crit_exc,
      vector_match = vector_match, 
      exposure = exposure,
      out = out, 
      follow_up = follow_up,
      base_test = base_test,
      temporal_var = temporal_var,
      verbose = FALSE,
      seed = seed) %>% 
    # descartar los días en los que no se encuentra matching
    keep(~is_tibble(.x)) %>%  
    # unir todos los tibbles de la lista en uno único
    enframe() %>%
    rename(target_trial_number = name) %>% 
    unnest(value) %>% 
    # para evitar errores en el matcheo
    filter(!is.na(exposicion))
  
}

```
