---
title: "Criterios de exclusión estáticos"
output: 
  html_document:
    code_folding: show
    highlight: espresso
    css: style.css
    keep_md: yes
    number_sections: yes
    theme: readable
    toc: yes  
    toc_float:
      collapsed: yes
      smooth_scroll: yes
      toc_depth: 3     
editor_options: 
  chunk_output_type: inline
---


```{r set-global-options, echo = FALSE}
knitr::opts_chunk$set(eval = TRUE, 
                      echo = TRUE, 
                      cache = FALSE,
                      include = TRUE,
                      collapse = FALSE,
                       dependson = NULL,
                      engine = "R", # Chunks will always have R code, unless noted
                      error = TRUE,
                      fig.path="Figures/",  # Set the figure options
                      fig.align = "center", 
                      fig.width = 12,
                      fig.height = 12)
```

```{r librerias, echo=FALSE, message=FALSE, include=FALSE, warning=FALSE}
# source("0_a_librerias.R")
# ya se cargan cuando se carguen las funciones

```

```{r}
# función para cargar un .Rmd como si se hiciese source de un .r---------------
source_rmd = function(file, ...) {
  tmp_file = tempfile(fileext = ".R")
  on.exit(unlink(tmp_file), add = TRUE)
  knitr::purl(file, output = tmp_file)
  source(file = tmp_file, ...)
}

```

```{r}
# cargar funciones de 0_funciones----------------------------------------------
if (!exists("se_ha_cargado_f")) {
source_rmd("0_b_funciones.rmd")
}

```


```{r cargar-datos, echo=FALSE, eval=TRUE, message=FALSE, warning=FALSE}
# cargar datos-----------------------------------------------------------------
# load(file.path("Datos", "Brutos", "ttcvc3d_220628.Rdata"))
pobana_2 <- readRDS(file = file.path("Resultados", "pobana_2.RDS"))
test220613_cleaned <- readRDS(file = file.path("Datos", "Procesados", 
                                             "test220613_cleaned.RDS"))

```

# Añadir múltiples tiempos

***

```{r nueva programacion con purrr}
# función de matching----------------------------------------------------------
f_matching_purrr_test <- function(data, 
                             tiempo_0, 
                             crit_exc,
                             exposure,
                             out,
                             censoring = "fdef",
                             vector_match,
                             follow_up = 60,
                             temporal_var = NULL,
                             base_test = NULL,
                             verbose = TRUE) {

  tiempo_0 <- ymd(tiempo_0)
  print(glue("tiempo_0 = {tiempo_0}"))
  if (verbose == TRUE) print(glue("Outcome = {out}"))
  if (verbose == TRUE) print(glue("n de partida: {nrow(data)}"))
  
  # exclusiones dependientes del tiempo
  for(i in seq_along(crit_exc$criterios)) {
  data <- excluir_dep(
                       pob = data,
                       crit = crit_exc$criterios[[i]],
                       var = crit_exc$variables[[i]],
                       t_var = crit_exc$tipo_var[[i]],
                       t0 = tiempo_0,
                       vb = verbose)
  }
  
  # exclusión por el outcome
    if (verbose == TRUE) print(glue("Variable exclusión. {out}"))
    if (out %in% crit_exc$variables) {
    if (verbose == TRUE) print("Criterio de exclusión ya aplicado")
    } else {
     data <- data %>% filter(is.na(get(out)) | get(out) >= tiempo_0)
    if (verbose == TRUE) print(glue("n : {nrow(pob)}"))
    }
  
  # obtención número de test negativos previos al primer positivo
  if (!is.null(base_test)) {
  data <- base_test %>% filter(id %in% data$id,
                               tpos == FALSE,
                               ftes < tiempo_0) %>% 
    group_by(id) %>% 
    summarise(n_0 = max(n)) %>% 
    right_join(data, by = "id") %>% 
    mutate(n_0 = case_when(is.na(n_0) ~ 0L, 
                 n_0 > 3 ~ 3L,
                 T ~ n_0)) 
  }
  # creación de variable temporal respecto a tiempo_0
  if (!is.null(temporal_var)) {
  data <- data %>% 
  mutate(temp_var = as.numeric(tiempo_0 - get(temporal_var)))
  }
  # exposicion-seguimiento
    data <- data %>% 
      mutate( exposicion = if_else(tiempo_0 == get(exposure) & 
                                     !is.na(get(exposure)), 1, 0),
              date_start = tiempo_0,
              date_end = tiempo_0 %m+% days(follow_up),
              date_end = if_else(!is.na(get(censoring)) & 
                          get(censoring) < date_end, get(censoring), date_end),
              date_end = if_else(exposicion == 0 & !is.na(get(exposure)) & 
                         get(exposure) < date_end,  get(exposure), date_end))

try({
    greedymatch <- Matching::Match(Tr = data$exposicion, M = 1, 
                   X = data[vector_match], exact = TRUE, ties = FALSE)
    a <- data[unlist(greedymatch[c("index.treated", "index.control")]),]
    par <- rep(1:(nrow(a)/2), 2)
    bind_cols(par = par, a) %>%
      group_by(par) %>%
      mutate(date_end = min(date_end),
        # creo la variable de resultado y finalizo el seguimiento cuando aparece)
         caso = if_else(get(out) <= date_end & !is.na(get(out)), 1, 0),
         date_end = if_else(caso == 1, get(out), date_end)) %>% 
      as_tibble() 
  }
  )
}

```

```{r}
prueba_matching_purrr_test <- f_matching_purrr_test(
                data = pobana_2,
                tiempo_0 = "2022-01-03",
                crit_exc = lista_exclusion_dep,
                vector_match = c("n_0", "temp_var"), 
                exposure = "fvc3",
                out = "fih1", 
                follow_up = 120,
                base_test = test220613_cleaned,
                temporal_var = "fpauta_90",
                verbose = FALSE)

```

# Prueba

```{r}
prueba_matching_purrr_test %>% 
  mutate(survtime = date_end - date_start) %>% 
  arrange(survtime)
# OK

prueba_matching_purrr %>% count(caso)
prueba_matching_purrr %>% count(exposicion)

```

```{r}
# fechas-----------------------------------------------------------------------
# fecha de inicio y fin: secuencia de fechas
fecha_inicio = ymd("2021-12-01")
fecha_fin = ymd("2022-06-01") 
fechas <- seq.Date(from = fecha_inicio, to = fecha_fin, by = "days")

```

```{r}
# pasar un listado de fechas---------------------------------------------------
prueba_matching_purrr_test_2 <- map(fechas, 
                f_matching_purrr_test,
                data = pobana_2,
                crit_exc = lista_exclusion_dep,
                vector_match = c(vector_match_4, "n_0", "temp_var"), 
                exposure = "fvc3",
                out = "fih1", 
                follow_up = 120,
                base_test = test220613_cleaned,
                temporal_var = "fpauta_90",
                verbose = FALSE) %>% 
    # descartar los días en los que no se encuentra matching
    keep(~is_tibble(.x)) %>%  
    # unir todos los tibbles de la lista en uno único
    enframe() %>%
    rename(target_trial_number = name) %>% 
    unnest(value) %>% 
    # para evitar errores en el matcheo
    filter(!is.na(exposicion))

```


```{r}
# check prueba-----------------------------------------------------------------
prueba_matching_purrr_test_2 %>% 
  janitor::tabyl(exposicion, caso) %>% 
  janitor::adorn_title()

prueba_matching_purrr_test_2  %>% 
  mutate(survtime = date_end - date_start) %>% 
  arrange(survtime)
# ok

```

